

Use Case ID: M1
Use Case Name: Sending Message
Relevant Requirements: 3.1.4.2, 3.1.4.3, 3.1.4.4, 3.1.4.6, 3.1.4.6.1, 3.1.4.6.4
Primary Actor: Sender 
Pre-condition: 
    Sender is called and provided data, current address, receiving address are provided (3.1.4.3)
Post-condition: 
    Package is sent
Basic Flow: 
    1. Sender is called and fork a Sender child
    2. Child call Processor to encapsulate a package
    3. Processor return package ready to be sent
    4. Child read receiving address on package and make a connection
    5. Once connection is made, package is sent
    6. kill Child
Alternate Flows:      
Exceptions: 
    If Sender is envoke with lacking arguements, throw error according to UI
Related Use Cases: M2, M3


Use Case ID: M2
Use Case Name: Receiving Message
Relevant Requirements: 3.1.4.2, 3.1.4.3, 3.1.4.4, 3.1.4.6, 3.1.4.6.1, 3.1.4.6.3
Primary Actor: Receiver
Pre-condition: 
    Receiver sit on designated network and listen for connections
Post-condition: 
    package received and decapsulated
Basic Flow: 
    1. Receiver fork a child upon handling an incoming package on listened port
    2. Assign the child to handle that request
    3. Child receive package from connection
    4. Child call Processor to decapsulate the package
    5. Child returns encapsulated data
    6. kill Child.
Alternate Flows: 
Exceptions:   
Related Use Cases: M1, M4

Use Case ID: M3
Use Case Name: Encapsulate data
Relevant Requirements:  
Primary Actor: Processor
Pre-condition: Processor get called with data
Post-condition: Processor returns a package
Basic Flow: 
Alternate Flows: 
Exceptions: 
Related Use Cases: 

Use Case ID: M4
Use Case Name: Decapsulate data
Relevant Requirements: 
Primary Actor: Processor
Pre-condition: Processor get called with a package
Post-condition: Processor returns encapsulated data
Basic Flow: 
Alternate Flows: 
Exceptions: 
Related Use Cases: 